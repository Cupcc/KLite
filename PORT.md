### 移植指南

#### 1.概述
    KLite核心代码完全使用C语言实现，由于不同CPU平台的差异性，
    对于与CPU平台有关的功能，无法使用相同的代码实现。
    这些无法统一实现的函数，系统提供了一个头文件定义了所有需要适配的函数接口，
    这个文件在source/kernel/port.h
```
    void cpu_sys_init(void);
    void cpu_sys_idle(uint32_t time);
    void cpu_irq_enable(void);
    void cpu_irq_disable(void);
    void cpu_tcb_init(struct tcb *tcb);
    void cpu_tcb_switch(void);
```
    除此之外，还需要为系统提供一个滴答时钟。
    滴答时钟使用硬件定时器中断，中断周期通常为1ms，也可以为其它任意值。
    只需要在中断服务程序中调用一次kernel_tick(1)即可。
    这里的参数1则代表时钟周期，如果是10ms中断一次，则应该传入10作为参数。

#### 2.函数说明
-------------------------------------------------------------------------------
    void cpu_sys_init(void)
    这个函数在系统初始化的时候调用。
    可以用于初始化系统时钟或其它必要的初始化。
    
-------------------------------------------------------------------------------
    void cpu_sys_idle(uint32_t time)
    这个函数在系统空闲的时候调用。
    参数time表示可以让CPU休眠的最大时间。
    可以用此实现TICKLESS模式。
    
-------------------------------------------------------------------------------
    void cpu_irq_disable(void)
    这个函数用于关闭CPU中断。
    需要屏蔽所有对系统可能产生竞争风险的中断。
    也可以简单处理，直接屏蔽所有中断。
    
-------------------------------------------------------------------------------
    void cpu_irq_enable(void)
    这个函数用于使能CPU中断
    恢复所有被cpu_irq_diable屏蔽的中断。
    
-------------------------------------------------------------------------------
    void cpu_tcb_init(struct tcb *tcb)
    这个函数用于初始化线程上下文。
    每当创建线程的时候，都会调用此函数，对线程的上下文进行初始化。
    参数tcb包含了线程上下文属性，这个函数可能用到tcb的以下几个成员：
    tcb->stack      //新线程的栈空间的地址
    tcb->stack_size //新线程的栈空间的长度
    tcb->entry      //新线程的入口函数地址
    tcb->arg        //新线程的入口函数参数
    
    移植这个函数时，需要实现以下功能：
    根据stack和stack_size的值，确定栈顶的地址，取决于目标CPU平台的堆栈增长方向。
    并把entry和arg参数按照正确的顺序压入堆栈；为了实现线程结束时自己释放空间，
    还需要把thread_exit函数的地址作为线程函数的返回地址正确地压入栈，
    最后把新的栈顶地址保存到tcb->stack。
    
-------------------------------------------------------------------------------
    void cpu_tcb_switch(void)
    这个函数用于切换上下文，通常用汇编代码实现。
    上下文切换的目标对象已经定义在全局变量，分别是：
    sched_tcb_now //当前线程上下文指针，将要被新线程取代
    sched_tcb_new //新的线程上下文指针，将要取代当前线程
    具体地，首先要判断sched_tcb_now是否为空指针，因为系统初始化的时候没有当前线程。
    如果为空指针，则跳过保存上下文的过程，直接恢复新的线程上下文。
    如果不为空指针，则先将当前CPU的上下文保存，再恢复新的线程上下文。
    最后再执行sched_tcb_now = sched_tcb_new。
    
    上下文保存方法：
    将当前CPU的所有上下文寄存器，按照特定的顺序压入当前线程的堆栈，
    并将当前更新后的栈顶地址保存到sched_tcb_now->stack。
    上下文恢复方法：
    将sched_tcb_new->stack读出，作为当前的堆栈，并按照压栈的顺序，
    将上下文寄存器从堆栈中弹出。
    
#### 3.参考示例
    详见源代码目录：source/port/
    